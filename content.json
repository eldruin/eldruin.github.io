{"pages":[{"title":"About me","date":"2018-08-25T16:39:00.000Z","updated":"2018-09-07T18:12:50.485Z","comments":true,"path":"about/index.html","permalink":"http://blog.eldruin.com/about/index.html","excerpt":"","text":"Hi, I am a computer engineer. I work at an applied research institute in Germany developing software in C++ and Python.Here I write mostly about programming, C++, Rust and embedded stuff.You may also know me because I wrote a japanese course for spanish speakers: Japonés por libre"}],"posts":[{"title":"OSEater","slug":"/oseater","date":"2012-02-05T14:04:48.000Z","updated":"2018-09-02T10:25:03.154Z","comments":true,"path":"/oseater/","link":"","permalink":"http://blog.eldruin.com/oseater/","excerpt":"","text":"OSEater is a “Pac-Man”-style game in which “Tux”, the Linux pet, has to collect all the dots in the map avoiding the Windows logos.Apple logos also exist and when they are eaten by Tux the game mode is changed and the hero can eat the Windows logos.Platform:It is developed for the nice LPC2378-STK board from Olimex, based on the LPC2378 microcontroller from NXP which has an ARM architecture.The peripherals used are the built in screen, joystick and digital to analog converter to play sounds.It is developed under an evaluation version of CrossWorks for GNU/Linux and was developed for the subject “Microcontrollers and microprocessors” of the university in aproximately 1 month.Design:OSEater follows an object oriented design using a component-based metodology in C++ programming language.Due to the strong hardware limitations and the short development time, the code is not as beautiful as it could be.Many thanks to my teacher Víctor Manuel Sánchez Corbacho for the development of the low-level interface for the board (which I cleaned up, translated and released as libOlimex-LPC2378-STK), to the freesound.org project and to the user HardPCM for creating the sounds I have used in this game.Source codeYou can find the full source code on GitHub.Low-level board interface library: libOlimex-LPC2378-STK","categories":[{"name":"embedded","slug":"embedded","permalink":"http://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"http://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"http://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"http://blog.eldruin.com/tags/game/"}]},{"title":"Sound2Header","slug":"/sound2header","date":"2012-01-28T18:04:48.000Z","updated":"2018-09-02T10:25:08.810Z","comments":true,"path":"/sound2header/","link":"","permalink":"http://blog.eldruin.com/sound2header/","excerpt":"","text":"Sound2Header (sound to header) is a little and simple C program that I have written using the libsndfile library to convert any sound file supported by libsndfile to an array of samples in a range given in the command line and write the result to a header file.The generated header file can be included in any C/C++ souce code file. It is intended for embedded projects where it is not possible to open files like when there is an operative system in place.Sound2Header is free software licensed under the GNU/GPL version 3 or later license. It can be easily compiled with make if you download the tarball from Github with:1makeor executing:1gcc -lsndfile sound2header.c -o sound2header(you need to have the libsndfile library installed, libsndfile-dev package in ubuntu)Many thanks to Erik de Castro Lopo for creating and mantaining the libsndfile library.Source codeRepository on Github: here","categories":[{"name":"embedded","slug":"embedded","permalink":"http://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"http://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"http://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"http://blog.eldruin.com/tags/game/"}]},{"title":"Inter-Process Communication: pipe(), fork() and C++ STL-like streams","slug":"/inter-process-communication-pipe-fork-cpp-stl-like-streams","date":"2011-04-22T07:04:48.000Z","updated":"2018-09-02T10:24:54.929Z","comments":true,"path":"/inter-process-communication-pipe-fork-cpp-stl-like-streams/","link":"","permalink":"http://blog.eldruin.com/inter-process-communication-pipe-fork-cpp-stl-like-streams/","excerpt":"","text":"I’ve run into some troubles lately trying to communicate processes through C++ STL-like streams with fork() and pipe() so I’ve created an example of how can this be done in a POSIX environment using the GCC’s libstdc++ (GCC &gt;= 3.4.0).The scenario is: A parent process wants to handle another program’s input and output streams, a process-level wrapper.So the example is: A parent process forks into another child process. The parent sends the child a message, the child receives it and outputs it to the parent to show the communication works just fine.The forked process calls the program we want to control. Which in this case is the easiest C++ program ever: Just reads a line from the standard input and outputs a message containing the line just read through the standard output. In addition, another message is sent through the standard error stream.Controlled programLet’s see the code for the controlled program:1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; string message; getline(cin, message); cout &lt;&lt; \"Program: I've received: \" &lt;&lt; \"'\" &lt;&lt; message &lt;&lt; \"'\" &lt;&lt; endl; cerr &lt;&lt; \"Program: This is the error stream!\" &lt;&lt; endl; return (0);&#125;As you can see we use the standard input/output streams cin, cout and cerr.Main ProgramNow let’s see chunks of the main program:123456789101112131415#define CHILD_STDIN_READ pipefds_input[0]#define CHILD_STDIN_WRITE pipefds_input[1]int pipefds_input[2], pipefds_output[2], pipefds_error[2];// Create the pipes// We do this before the fork so both processes will know about// the same pipe and they can communicate.pipe_status = pipe(pipefds_input);if (pipe_status == -1)&#123; perror(\"Error creating the pipe\"); exit(EXIT_FAILURE);&#125;With the definitions you won’t mistake the pipe ends.We repeat the same process for the pipes for standard output and error.fork() skeleton1234567891011121314151617pid_t pid;pid = fork();if (pid == pid_t(0))&#123; // Child process&#125;else if (pid &gt; pid_t(0))&#123; // Parent&#125;else&#123; // Error: fork failed&#125;// Shared codeThis is the skeleton for a fork(). When you call fork() a new process is created in memory and the pid return value is set to two different values in each process.Standard streams tying1234567891011121314// Child Process// Tie the standard input, output and error streams to the// appropiate pipe ends// The file descriptor 0 is the standard input// We tie it to the read end of the pipe as we will use// this end of the pipe to read from it// Same for the othersdup2 (CHILD_STDIN_READ,0);dup2 (CHILD_STDOUT_WRITE,1); // standard outputdup2 (CHILD_STDERR_WRITE,2); // standard error// Close in the child the unused ends of the pipesclose(CHILD_STDIN_WRITE);close(CHILD_STDOUT_READ);close(CHILD_STDERR_READ);In each process we only use one end of the pipes, this is, in the child, we only read from stdin and only write to stdout and stderr. So we close the other ends.We do the same in the parent process, but don’t need to tie anything this time.exec()In the child we execute the program to be controlled through execl()123// Child// Execute the programexecl(\"./program\", \"program\", (char*)NULL);When you call exec(), the called program replaces the executing program, so the streams of the called program are still tied to our pipes.Sending messagesEverything is set up now! Let’s send messages!12345678910111213// Parentstring message;cout &lt;&lt; \"Parent: I'll send the child a message.\" &lt;&lt; endl;ofdstream in_stream(CHILD_STDIN_WRITE);in_stream &lt;&lt; \"Hello Child!\\n\";ifdstream out_stream(CHILD_STDOUT_READ);getline(out_stream, message);cout &lt;&lt; \"Parent: Child just said through stdout: \" &lt;&lt; endl &lt;&lt; \"\\t\\\"\" &lt;&lt; message &lt;&lt; \"\\\"\" &lt;&lt; endl;We send the message “Hello Child!” through the write end of the child’s stdin pipe.The child process get it and outputs another message that we read from the read end of the child’s stdout pipe.Pipes I/O with file descriptors using C++ STL streamsYou can see here two simple functions to read and write strings through pipes using file descriptors and C++ STL-like input/output streams.1234567891011121314151617181920212223string read_from_pipe (int file_descriptor)&#123; // We create a C++ stream from a file descriptor // stdio_filebuf is not synced with stdio. // From GCC 3.4.0 on exists in addition stdio_sync_filebuf // You can also create the filebuf from a FILE* with // FILE* f = fdopen(file_descriptor, mode); __gnu_cxx::stdio_filebuf&lt;char&gt; filebuf(file_descriptor, std::ios_base::in); istream stream(&amp;filebuf); // You can also do: // ostringstream stream; // stream &lt;&lt; &amp;filebuf; // return stream.str(); string line; if (stream.good()) &#123; getline(stream, line); &#125; return line;&#125;1234567891011void write_to_pipe (int file_descriptor, const string&amp; line)&#123; __gnu_cxx::stdio_filebuf&lt;char&gt; filebuf(file_descriptor, std::ios_base::out); ostream stream(&amp;filebuf); if (stream.good()) &#123; stream &lt;&lt; line; &#125;&#125;I use the __gnu_cxx::stdio_filebuf class. This class is part of the GNU extensions of the libstdc++ library.From the library documentation:[This class] Provides a layer of compatibility for C/POSIX.This GNU extension provides extensions for working with standard C FILE*’s and POSIX file descriptors. It must be instantiated by the user with the type of character used in the file stream, e.g., stdio_filebuf&lt;char&gt;.With this object we can create a STL istream or ostream giving its contructor the address of our object.I’ve created two C++ classes so we can interact with the child’s streams like they were C++ STL streams instead of using these functions. You can see here the interface.123456789101112131415161718192021class ifdstream : public _fdstream&#123;public: ifdstream(); ifdstream(int file_descriptor); void open(int file_descriptor); ifdstream&amp; operator&gt;&gt; (string&amp; str); size_t getline (char* s, streamsize n); size_t getline (char* s, streamsize n, char delim); ~ifdstream();&#125;;class ofdstream : public _fdstream&#123;public: ofdstream(); ofdstream(int file_descriptor); void open(int file_descriptor); ofdstream&amp; operator&lt;&lt; (const string&amp; str); ~ofdstream();&#125;;With these classes you can create STL-like C++ streams from your file descriptors so you can read and write from/to the pipes with the usual &gt;&gt; and &lt;&lt; operators. I haven’t implemented more functions as this is only a demonstration.That’s all folks! You can now create families of talking processes!Source codeYou can find the full source code on GitHub.The code is in the public domain, you can do whatever you want with it.Improvements and comments are most appreciated.Of course this code is for educational purposes only. If you want to do something serious about file descriptors and C++ streams have a look at boost::iostreams::file_descriptor and boost::iostreams::stream.ResourcesSouce code repositoryYoLinux Tutorial: Fork, Exec and Process controlAdvanced Linux Programming Book: IPC chapterLinux Programmer’s GuideThe GNU C Library manualThe GNU C++ Library manualfileno(3) on C++ Streams: A Hacker’s Lament, Richard B. Kreckel","categories":[{"name":"programming","slug":"programming","permalink":"http://blog.eldruin.com/categories/programming/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://blog.eldruin.com/tags/c/"},{"name":"ipc","slug":"ipc","permalink":"http://blog.eldruin.com/tags/ipc/"},{"name":"stl","slug":"stl","permalink":"http://blog.eldruin.com/tags/stl/"}]},{"title":"DSMemorizer","slug":"/dsmemorizer","date":"2009-10-01T07:04:48.000Z","updated":"2018-09-02T10:24:49.349Z","comments":true,"path":"/dsmemorizer/","link":"","permalink":"http://blog.eldruin.com/dsmemorizer/","excerpt":"","text":"DSMemorizer is a homebrew game for the Nintendo DS (also playable in any emulator like DeSmuMe) to help memorizing japanese vocabulary and kanjis (ideograms).DSMemorizer is written in C++ following an object oriented programming. It uses the libraries libnds, EFS_lib for the files, freetype for font rendering and UTF8-CPP to process UTF-8 files. For the databases of symbols and words it uses UTF-8 encoded XML files. The documentation can be generated by Doxygen.It is possible to write your own database in your own language in XML format.Source codeYou can find the souce code of the game here","categories":[{"name":"embedded","slug":"embedded","permalink":"http://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"http://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"http://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"http://blog.eldruin.com/tags/game/"}]}]}