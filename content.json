{"pages":[{"title":"About me","date":"2018-08-25T16:39:00.000Z","updated":"2018-09-10T17:26:25.259Z","comments":true,"path":"about/index.html","permalink":"https://blog.eldruin.com/about/index.html","excerpt":"","text":"Hi, I am a computer engineer. I work at an applied research institute in Germany developing medical software in C++ and Python.Here I write mostly about programming, C++, Rust and embedded stuff.You may also know me because I wrote a japanese course for spanish speakers: Japonés por libre"}],"posts":[{"title":"Ads1x1x Analog-to-Digital Converter Driver in Rust","slug":"/ads1x1x-analog-to-digital-converter-driver-in-rust","date":"2019-03-31T12:22:17.000Z","updated":"2019-03-31T14:56:31.913Z","comments":true,"path":"/ads1x1x-analog-to-digital-converter-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/ads1x1x-analog-to-digital-converter-driver-in-rust/","excerpt":"","text":"&nbsp;Today I present you an analog-to-digital converter (ADC) Rust driver compatible with the devices ADS1013, ADS1014, ADS1015, ADS1113, ADS1114 and ADS1115.The devicesThe devices are precision, low power, 12/16-bit analog-to-digital converters (ADC) that provide all features necessary to measure the most common sensor signals in an ultra-small package. Depending on the device, these integrate a programmable gain amplifier (PGA), voltage reference,oscillator and high-accuracy temperature sensor.The devices can perform conversions at data rates up to 3300 samples per second (SPS). The PGA offers input ranges from ±256 mV to ±6.144 V, allowing both large and small signals to be measured with high resolution. An input multiplexer (MUX) allows to measure two differential or four single-ended inputs. The high-accuracy temperature sensor can be used for system-level temperature monitoring or cold-junction compensation for thermocouples.The devices operate either in continuous-conversion mode, or in a single-shot mode that automatically powers down after a conversion. Single-shot mode significantly reduces current consumption during idle periods. Data is transferred through I2C.You can buy a module board containing this from AliExpress or eBay.Using the driverTo use the device from Rust, you have to add the ads1x1x crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux, you can use linux-embedded-hal.12345# Cargo.toml...[dependencies]ads1x1x = \"0.2\"linux-embedded-hal = \"0.1\"Voltage divider exampleIn the title picture in this post I created a voltage divider circuit using 3 resistors of equal value and connected the points in the divider to the inputs of the ADC.A voltage divider is a circuit that can “divide” the voltage and output a voltage in between,proportional to the resistences in place.Here is the circuit schematic:The resistor values do not matter much but it is nicer to understand if they are all of the same value.With this setup we should get the reading for +5V on channel A0, the reading for GND on channel A3 and A1 and A2 equally spaced in between (within resistence tolerances).I get these values:Channel 0: 1575Channel 1: 1051Channel 2: 524Channel 3: 0We can calculate the relations and voltage that correspond to each channel if weassume that 1575 corresponds to 5V.ChannelFactorVoltage01575 / 1575=1* 5V=5V11051 / 1575=0.667* 5V=3.34V2524 / 1575=0.333* 5V=1.66V30 / 1575=0* 5V=0VAs you can see, the voltage was divided equally by all resistors.The program1234567891011121314151617181920212223242526extern crate embedded_hal;use embedded_hal::adc::OneShot;extern crate linux_embedded_hal;#[macro_use(block)]extern crate nb;extern crate ads1x1x;use ads1x1x::&#123;channel, Ads1x1x, SlaveAddr&#125;;use linux_embedded_hal::I2cdev;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut adc = Ads1x1x::new_ads1015(dev, address); let values = [ block!(adc.read(&amp;mut channel::SingleA0)).unwrap(), block!(adc.read(&amp;mut channel::SingleA1)).unwrap(), block!(adc.read(&amp;mut channel::SingleA2)).unwrap(), block!(adc.read(&amp;mut channel::SingleA3)).unwrap(), ]; for (channel, value) in values.iter().enumerate() &#123; println!(\"Channel &#123;&#125;: &#123;&#125;\", channel, value); &#125; // get I2C device back let _dev = adc.destroy_ads1015();&#125;This example is also available in the crate sources here.In the title picture you can see this running on the STMF3Discovery board and printing the results on an OLED display. You can find the source code of that program here.In the driver-examples repository you can find further examples of using these devices like measuring the output of a digital potentiometer (digipot) and a digital-to-analog converter (DAC).Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links:Source: https://github.com/eldruin/ads1x1x-rsCrate: https://crates.io/crates/ads1x1xDocumentation: https://docs.rs/ads1x1x","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"TMP1x2 Temperature Sensor Driver in Rust","slug":"/tmp1x2-temperature-sensor-driver-in-rust","date":"2019-03-17T09:22:17.000Z","updated":"2019-03-17T16:20:42.717Z","comments":true,"path":"/tmp1x2-temperature-sensor-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/tmp1x2-temperature-sensor-driver-in-rust/","excerpt":"","text":"&nbsp;I have continued writing several Rust device drivers. Today I present you a Rust driver for the TMP102 and TMP112 high-accuracy, low-power, digital temperature sensors.The devicesThis driver is compatible with both the TMP102 device as well as the TMP112 family of devices, including TMP112A, TMP112B and TMP112N.These temperature sensors are highly linear and do not require complex calculations or lookup tables to derive the temperature. The on-chip 12-bit ADC offers resolutions down to 0.0625°C.The TMP102 device is a digital temperature sensor ideal for NTC/PTC thermistor replacement where high accuracy is required. The device offers an accuracy of +/-0.5°C without requiring calibration or external component signal conditioning.The TMP112 family of devices are digital temperature sensors designed for high-accuracy, low-power, NTC/PTC thermistor replacements where high accuracy is required. The TMP112A and TMP112B offers 0.5°C accuracy and are optimized to provide the best PSR performance for 3.3V and 1.8V operation respectively, while TMP112N offers 1°C accuracy.The communication is done serially through an I²C, bidirectional bus.Datasheets:TMP102TMP112xYou can buy a module board containing this from AliExpress or eBay.The driverThis driver allows you to:Change into one-shot or continuous conversion mode.Read the temperature.Enable/disable the extended measurement mode.Trigger a one-shot measurement.Read whether the one-shot measurement result is ready.Set the conversion rate.Set the high/low temperature threshold.Set the fault queue.Set the alert polarity.Set the thermostat mode.Read whether a comparator mode alert is active.Using the driverTo use the device from Rust, you have to add the tmp1x2 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux, you can use linux-embedded-hal.12345# Cargo.toml...[dependencies]tmp1x2 = \"0.2\"linux-embedded-hal = \"0.1\"This is an example program which will measure the temperature and print it (in Celsius).123456789101112extern crate linux_embedded_hal as hal;extern crate tmp1x2;use tmp1x2::&#123;SlaveAddr, Tmp1x2&#125;;fn main() &#123; let dev = hal::I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut sensor = Tmp1x2::new(dev, address); let temperature = sensor.read_temperature().unwrap(); println!(\"Temperature: &#123;:.1&#125;ºC\", temperature);&#125;This example is also available in the crate sources here.I created a repository where you can find examples of this and several other devices running on the STMF3Discovery board: driver-examplesThere you can find the code of the program running on the title image of this post. There I read the ambient temperature and print it to an SSD1306 OLED display both sharing the same I²C bus.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links:Source: https://github.com/eldruin/tmp1x2-rsCrate: https://crates.io/crates/tmp1x2Documentation: https://docs.rs/tmp1x2","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"TMP006 Contact-less Infrared (IR) Thermopile Temperature Sensor Driver in Rust","slug":"/tmp006-contact-less-infrared-ir-thermopile-driver-in-rust","date":"2018-12-07T17:22:17.000Z","updated":"2018-12-07T12:26:34.602Z","comments":true,"path":"/tmp006-contact-less-infrared-ir-thermopile-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/tmp006-contact-less-infrared-ir-thermopile-driver-in-rust/","excerpt":"","text":"I have been writing several platform-agnostic Rust drivers (15 published at the moment) as a way to push embedded development in Rust forward. Today I present you a Rust driver for the TMP006.The TMP006 is a pretty cool device that can measure the temperature of an object without touching it. An infrared thermopile.The devicesThe TMP006 and TMP006B are the first in a series of temperature sensors that measure the temperature of an object without the need to make contact with the object. This sensor uses a thermopile to absorb the infrared energy emitted from the object being measured and uses the corresponding change in thermopile voltage to determine the object temperature.Infrared sensor voltage range is specified from -40°C to +125°C to enable use in a wide range of applications. Low power consumption along with low operating voltage makes the device suitable for battery-powered applications. The low package height of the chip-scale format enables standard high- volume assembly methods, and can be useful where limited spacing to the object being measured is available.The communication is done serially through an I²C, bidirectional bus.Datasheet: TMP006/BUser guide: TMP006 user guideYou can buy this from Adafruit or AliExpress.The driverThis driver allows you to:Enable/disable the device. See: enable().Read the object temperature. See: read_object_temperature().Read the object voltage and ambient temperature raw data. See: read_sensor_data().Calculate the object temperature from the sensor raw data. See: calculate_object_temperature().Set the ADC conversion rate. See: set_conversion_rate().Enable/disable the DRDY pin. See: enable_drdy_pin().Read whether data is ready to be read. See: is_data_ready().Perform a software reset. See: reset().Read the manufacturer ID. See: read_manufacturer_id().Read the device ID. See: read_device_id().Using the driverTo use the device from Rust, you have to add the tmp006 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux, you can use linux-embedded-hal.12345# Cargo.toml...[dependencies]tmp006 = \"0.2\"linux-embedded-hal = \"0.1\"This is an example program which will measure the temperature and print it (in Kelvins).12345678910111213141516extern crate linux_embedded_hal as hal;extern crate tmp006;use hal::I2cdev;use tmp006::&#123;Tmp006, SlaveAddr&#125;;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut sensor = Tmp006::new(dev, address); let calibration_factor = 6e-14; let temperature = sensor .read_object_temperature(calibration_factor) .unwrap(); println!(\"Temperature: &#123;&#125;K\", temperature);&#125;This example is also available in the crate sources here.I created a separate repository for additional examples: tmp006-examples.There you can find the code of the program running on the title image of this post. There I read the temperature from a tea cup and print it to an SSD1306 OLED display both sharing the same I²C bus.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?As I said, I have been writing several platform-agnostic Rust drivers (15 published at the moment) and will announce them here soon.Thanks for reading and stay tuned!Links:Source: https://github.com/eldruin/tmp006-rsCrate: https://crates.io/crates/tmp006Documentation: https://docs.rs/tmp006","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"DS1307 Real-Time Clock (RTC) Driver in Rust","slug":"/ds1307-real-time-clock-rtc-driver-in-rust","date":"2018-09-24T17:25:37.000Z","updated":"2018-09-24T17:26:10.469Z","comments":true,"path":"/ds1307-real-time-clock-rtc-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/ds1307-real-time-clock-rtc-driver-in-rust/","excerpt":"","text":"After writing the 24x Serial EEPROM IC driver I have written a driver for the DS1307 real-time clock as part of the Weekly Driver Initiative. This platform-agnostic driver is based on embedded-hal.Modules containing this IC often come often together with a button battery holder like in the picture above and an AT24C32 EEPROM (Electrically Erasable and Programmable Read-Only Memory) IC. Please refer to the 24x Serial EEPROM IC driver to use that IC.I wrote this driver following Test-Driven-Development using the embedded-hal-mock crate which was very helpful.The deviceThe DS1307 serial real-time clock (RTC) is a low-power, full binary-coded decimal (BCD) clock/calendar plus 56 bytes of NV SRAM. Address and data are transferred serially through an I²C, bidirectional bus.The clock/calendar provides seconds, minutes, hours, day, date, month, and year information. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap year. The clock operates in either the 24-hour or 12-hour format with AM/PM indicator.The DS1307 has a built-in power-sense circuit that detects power failures and automatically switches to the backup supply. Timekeeping operation continues while the part operates from the backup supply.Datasheet: DS1307In this blog post I will use a module similar to the one in the picute. You can buy the device on AliExpress or eBay for a few cents.The driverThis driver allows you to:Read and set date and time in 12-hour and 24-hour format. See: get_datetimeEnable and disable the real-time clock. See: set_runningRead and write user RAM. See: read_ramControl square-wave output. See: enable_square_wave_outputUsing the driverTo use the device from Rust, you have to add the ds1307 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux, you can use linux-embedded-hal.12345# Cargo.toml...[dependencies]ds1307 = \"0.2\"linux-embedded-hal = \"0.1\"This is an example program which will set the date and time and then read it back:123456789101112131415161718192021222324252627282930313233343536373839extern crate linux_embedded_hal as hal;extern crate ds1307;use hal::I2cdev;use ds1307::&#123;DS1307, DateTime, Hours&#125;;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let mut rtc = DS1307::new(dev); let datetime = DateTime &#123; year: 2018, month: 08, day: 15, weekday: 4, hour: Hours::H24(19), minute: 59, second: 58 &#125;; rtc.set_datetime(&amp;datetime).unwrap(); let datetime = rtc.get_datetime().unwrap(); // The hours depend on the RTC running mode. match datetime.hour &#123; Hours::H24(h) =&gt; println!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;, &#123;&#125; &#123;&#125;:&#123;&#125;:&#123;&#125;\", datetime.year, datetime.month, datetime.day, datetime.weekday, h, datetime.minute, datetime.second), Hours::AM(h) =&gt; println!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;, &#123;&#125; &#123;&#125;:&#123;&#125;:&#123;&#125; AM\", datetime.year, datetime.month, datetime.day, datetime.weekday, h, datetime.minute, datetime.second), Hours::PM(h) =&gt; println!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;, &#123;&#125; &#123;&#125;:&#123;&#125;:&#123;&#125; PM\", datetime.year, datetime.month, datetime.day, datetime.weekday, h, datetime.minute, datetime.second), &#125; // This will print something like: 2018-08-15, 4 19:59:58&#125;This example is also available in the crate sources here.The driver also allows individual access to the year, month, day, etc. through functions like:set_year(), get_year() and so on.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have a WIP driver for the popular I/O expanders PCF8574, PCF8574A and PCF8575 and another WIP one for the TCA9548A and PCA9548A I2C switches/multiplexers. I will announce them here soon.Thanks for reading and stay tuned!Links:Source: https://github.com/eldruin/ds1307-rsCrate: https://crates.io/crates/ds1307Documentation: https://docs.rs/ds1307","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"24x Serial EEPROM ICs driver in Rust","slug":"/24x-serial-eeprom-driver-in-rust","date":"2018-09-09T11:49:37.000Z","updated":"2018-09-10T17:24:52.383Z","comments":true,"path":"/24x-serial-eeprom-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/24x-serial-eeprom-driver-in-rust/","excerpt":"","text":"I have been learning Rust on and off for quite a while and embedded systems have always been interesting for me.At some point I discovered the Discovery book and decided to turn back to the embedded fun I did not touch since my childhood.After completing the book I was looking for something useful to do and wrote this driver for the common 24x Serial EEPROM IC series as part of the Weekly Driver Initiative. This platform-agnostic driver is based on embedded-hal.I wrote this driver following Test-Driven-Development using the embedded-hal-mock crate which was very helpful.The devicesThe devices are serial EEPROM (Electrically Erasable and Programmable Read-Only Memory) ICs, with different capacities, which communicate using I²C. With these devices it is possible to store data which will persist on the absence of power.There are many vendors that have compatible ICs on their portfolios and seem to have a common “24“ family name, hence the name of the driver.For example, Microchip has ICs like AT24C32, 24AA32A and AT24C256 whereas STMicroelectronics has ICs like M24C32.There may also be other vendors that have compatible ICs under a different name. If you know of some of these, please let me know and I will add them to the list of compatible devices.This driver attempts to be compatible with many of these ICs.In this blog post I will use the AT24C256C. You can buy the device on AliExpress or eBay for a few cents.There are also many Real-Time-Clock (RTC) modules, typically for Arduino, that include an RTC IC like the DS1307 and also an AT24C32 EEPROM IC so you may already have an EEPROM IC that you can use.The driverThis driver allows you to:Read a single byte from a memory address. See: read_byteRead a byte array starting on a memory address. See: read_dataRead the current memory address (please read notes). See: read_current_addressWrite a byte to a memory address. See: write_byteWrite a byte array (up to a memory page) to a memory address. See: write_pageCan be used at least with the devices AT24C32, AT24C64, AT24C128, AT24C256 and AT24C512.Using the driverTo use the device from Rust, you have to add the eeprom24x crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux, you can use linux-embedded-hal.12345# Cargo.toml...[dependencies]eeprom24x = \"0.1\"linux-embedded-hal = \"0.1\"This is an example program writing and reading some data from the memory:1234567891011121314151617181920212223extern crate embedded_hal;extern crate linux_embedded_hal;extern crate eeprom24x;use embedded_hal::blocking::delay::DelayMs;use linux_embedded_hal::&#123;I2cdev, Delay&#125;;use eeprom24x::&#123;Eeprom24x, SlaveAddr&#125;;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let mut eeprom = Eeprom24x::new_24x256(dev, SlaveAddr::default()); let memory_address = [0x12, 0x34]; let data = 0xAB; eeprom.write_byte(&amp;memory_address, data).unwrap(); Delay.delay_ms(5u16); let retrieved_data = eeprom.read_byte(&amp;memory_address).unwrap(); println!(\"Read memory address: [&#123;&#125;,&#123;&#125;], retrieved content: &#123;&#125;\", memory_address[0], memory_address[1], &amp;retrieved_data);&#125;This example is also available in the crate sources here.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have a driver for the popular DS1307 real-time clock (RTC) and a WIP driver for the popular I/O expanders PCF8574, PCF8574A and PCF8575. I will announce them here soon.Thanks for reading and stay tuned!Links:Crate: https://crates.io/crates/eeprom24xDocumentation: https://docs.rs/eeprom24xSource: https://github.com/eldruin/eeprom24x-rs","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"OSEater","slug":"/oseater","date":"2012-02-05T14:04:48.000Z","updated":"2018-09-02T10:25:03.154Z","comments":true,"path":"/oseater/","link":"","permalink":"https://blog.eldruin.com/oseater/","excerpt":"","text":"OSEater is a “Pac-Man”-style game in which “Tux”, the Linux pet, has to collect all the dots in the map avoiding the Windows logos.Apple logos also exist and when they are eaten by Tux the game mode is changed and the hero can eat the Windows logos.Platform:It is developed for the nice LPC2378-STK board from Olimex, based on the LPC2378 microcontroller from NXP which has an ARM architecture.The peripherals used are the built in screen, joystick and digital to analog converter to play sounds.It is developed under an evaluation version of CrossWorks for GNU/Linux and was developed for the subject “Microcontrollers and microprocessors” of the university in aproximately 1 month.Design:OSEater follows an object oriented design using a component-based metodology in C++ programming language.Due to the strong hardware limitations and the short development time, the code is not as beautiful as it could be.Many thanks to my teacher Víctor Manuel Sánchez Corbacho for the development of the low-level interface for the board (which I cleaned up, translated and released as libOlimex-LPC2378-STK), to the freesound.org project and to the user HardPCM for creating the sounds I have used in this game.Source codeYou can find the full source code on GitHub.Low-level board interface library: libOlimex-LPC2378-STK","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"https://blog.eldruin.com/tags/game/"}]},{"title":"Sound2Header","slug":"/sound2header","date":"2012-01-28T18:04:48.000Z","updated":"2018-09-02T10:25:08.810Z","comments":true,"path":"/sound2header/","link":"","permalink":"https://blog.eldruin.com/sound2header/","excerpt":"","text":"Sound2Header (sound to header) is a little and simple C program that I have written using the libsndfile library to convert any sound file supported by libsndfile to an array of samples in a range given in the command line and write the result to a header file.The generated header file can be included in any C/C++ souce code file. It is intended for embedded projects where it is not possible to open files like when there is an operative system in place.Sound2Header is free software licensed under the GNU/GPL version 3 or later license. It can be easily compiled with make if you download the tarball from Github with:1makeor executing:1gcc -lsndfile sound2header.c -o sound2header(you need to have the libsndfile library installed, libsndfile-dev package in ubuntu)Many thanks to Erik de Castro Lopo for creating and mantaining the libsndfile library.Source codeRepository on Github: here","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"https://blog.eldruin.com/tags/game/"}]},{"title":"Inter-Process Communication: pipe(), fork() and C++ STL-like streams","slug":"/inter-process-communication-pipe-fork-cpp-stl-like-streams","date":"2011-04-22T07:04:48.000Z","updated":"2018-09-02T10:24:54.929Z","comments":true,"path":"/inter-process-communication-pipe-fork-cpp-stl-like-streams/","link":"","permalink":"https://blog.eldruin.com/inter-process-communication-pipe-fork-cpp-stl-like-streams/","excerpt":"","text":"I’ve run into some troubles lately trying to communicate processes through C++ STL-like streams with fork() and pipe() so I’ve created an example of how can this be done in a POSIX environment using the GCC’s libstdc++ (GCC &gt;= 3.4.0).The scenario is: A parent process wants to handle another program’s input and output streams, a process-level wrapper.So the example is: A parent process forks into another child process. The parent sends the child a message, the child receives it and outputs it to the parent to show the communication works just fine.The forked process calls the program we want to control. Which in this case is the easiest C++ program ever: Just reads a line from the standard input and outputs a message containing the line just read through the standard output. In addition, another message is sent through the standard error stream.Controlled programLet’s see the code for the controlled program:1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; string message; getline(cin, message); cout &lt;&lt; \"Program: I've received: \" &lt;&lt; \"'\" &lt;&lt; message &lt;&lt; \"'\" &lt;&lt; endl; cerr &lt;&lt; \"Program: This is the error stream!\" &lt;&lt; endl; return (0);&#125;As you can see we use the standard input/output streams cin, cout and cerr.Main ProgramNow let’s see chunks of the main program:123456789101112131415#define CHILD_STDIN_READ pipefds_input[0]#define CHILD_STDIN_WRITE pipefds_input[1]int pipefds_input[2], pipefds_output[2], pipefds_error[2];// Create the pipes// We do this before the fork so both processes will know about// the same pipe and they can communicate.pipe_status = pipe(pipefds_input);if (pipe_status == -1)&#123; perror(\"Error creating the pipe\"); exit(EXIT_FAILURE);&#125;With the definitions you won’t mistake the pipe ends.We repeat the same process for the pipes for standard output and error.fork() skeleton1234567891011121314151617pid_t pid;pid = fork();if (pid == pid_t(0))&#123; // Child process&#125;else if (pid &gt; pid_t(0))&#123; // Parent&#125;else&#123; // Error: fork failed&#125;// Shared codeThis is the skeleton for a fork(). When you call fork() a new process is created in memory and the pid return value is set to two different values in each process.Standard streams tying1234567891011121314// Child Process// Tie the standard input, output and error streams to the// appropiate pipe ends// The file descriptor 0 is the standard input// We tie it to the read end of the pipe as we will use// this end of the pipe to read from it// Same for the othersdup2 (CHILD_STDIN_READ,0);dup2 (CHILD_STDOUT_WRITE,1); // standard outputdup2 (CHILD_STDERR_WRITE,2); // standard error// Close in the child the unused ends of the pipesclose(CHILD_STDIN_WRITE);close(CHILD_STDOUT_READ);close(CHILD_STDERR_READ);In each process we only use one end of the pipes, this is, in the child, we only read from stdin and only write to stdout and stderr. So we close the other ends.We do the same in the parent process, but don’t need to tie anything this time.exec()In the child we execute the program to be controlled through execl()123// Child// Execute the programexecl(\"./program\", \"program\", (char*)NULL);When you call exec(), the called program replaces the executing program, so the streams of the called program are still tied to our pipes.Sending messagesEverything is set up now! Let’s send messages!12345678910111213// Parentstring message;cout &lt;&lt; \"Parent: I'll send the child a message.\" &lt;&lt; endl;ofdstream in_stream(CHILD_STDIN_WRITE);in_stream &lt;&lt; \"Hello Child!\\n\";ifdstream out_stream(CHILD_STDOUT_READ);getline(out_stream, message);cout &lt;&lt; \"Parent: Child just said through stdout: \" &lt;&lt; endl &lt;&lt; \"\\t\\\"\" &lt;&lt; message &lt;&lt; \"\\\"\" &lt;&lt; endl;We send the message “Hello Child!” through the write end of the child’s stdin pipe.The child process get it and outputs another message that we read from the read end of the child’s stdout pipe.Pipes I/O with file descriptors using C++ STL streamsYou can see here two simple functions to read and write strings through pipes using file descriptors and C++ STL-like input/output streams.1234567891011121314151617181920212223string read_from_pipe (int file_descriptor)&#123; // We create a C++ stream from a file descriptor // stdio_filebuf is not synced with stdio. // From GCC 3.4.0 on exists in addition stdio_sync_filebuf // You can also create the filebuf from a FILE* with // FILE* f = fdopen(file_descriptor, mode); __gnu_cxx::stdio_filebuf&lt;char&gt; filebuf(file_descriptor, std::ios_base::in); istream stream(&amp;filebuf); // You can also do: // ostringstream stream; // stream &lt;&lt; &amp;filebuf; // return stream.str(); string line; if (stream.good()) &#123; getline(stream, line); &#125; return line;&#125;1234567891011void write_to_pipe (int file_descriptor, const string&amp; line)&#123; __gnu_cxx::stdio_filebuf&lt;char&gt; filebuf(file_descriptor, std::ios_base::out); ostream stream(&amp;filebuf); if (stream.good()) &#123; stream &lt;&lt; line; &#125;&#125;I use the __gnu_cxx::stdio_filebuf class. This class is part of the GNU extensions of the libstdc++ library.From the library documentation:[This class] Provides a layer of compatibility for C/POSIX.This GNU extension provides extensions for working with standard C FILE*’s and POSIX file descriptors. It must be instantiated by the user with the type of character used in the file stream, e.g., stdio_filebuf&lt;char&gt;.With this object we can create a STL istream or ostream giving its contructor the address of our object.I’ve created two C++ classes so we can interact with the child’s streams like they were C++ STL streams instead of using these functions. You can see here the interface.123456789101112131415161718192021class ifdstream : public _fdstream&#123;public: ifdstream(); ifdstream(int file_descriptor); void open(int file_descriptor); ifdstream&amp; operator&gt;&gt; (string&amp; str); size_t getline (char* s, streamsize n); size_t getline (char* s, streamsize n, char delim); ~ifdstream();&#125;;class ofdstream : public _fdstream&#123;public: ofdstream(); ofdstream(int file_descriptor); void open(int file_descriptor); ofdstream&amp; operator&lt;&lt; (const string&amp; str); ~ofdstream();&#125;;With these classes you can create STL-like C++ streams from your file descriptors so you can read and write from/to the pipes with the usual &gt;&gt; and &lt;&lt; operators. I haven’t implemented more functions as this is only a demonstration.That’s all folks! You can now create families of talking processes!Source codeYou can find the full source code on GitHub.The code is in the public domain, you can do whatever you want with it.Improvements and comments are most appreciated.Of course this code is for educational purposes only. If you want to do something serious about file descriptors and C++ streams have a look at boost::iostreams::file_descriptor and boost::iostreams::stream.ResourcesSouce code repositoryYoLinux Tutorial: Fork, Exec and Process controlAdvanced Linux Programming Book: IPC chapterLinux Programmer’s GuideThe GNU C Library manualThe GNU C++ Library manualfileno(3) on C++ Streams: A Hacker’s Lament, Richard B. Kreckel","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.eldruin.com/categories/programming/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"ipc","slug":"ipc","permalink":"https://blog.eldruin.com/tags/ipc/"},{"name":"stl","slug":"stl","permalink":"https://blog.eldruin.com/tags/stl/"}]},{"title":"DSMemorizer","slug":"/dsmemorizer","date":"2009-10-01T07:04:48.000Z","updated":"2018-09-02T10:24:49.349Z","comments":true,"path":"/dsmemorizer/","link":"","permalink":"https://blog.eldruin.com/dsmemorizer/","excerpt":"","text":"DSMemorizer is a homebrew game for the Nintendo DS (also playable in any emulator like DeSmuMe) to help memorizing japanese vocabulary and kanjis (ideograms).DSMemorizer is written in C++ following an object oriented programming. It uses the libraries libnds, EFS_lib for the files, freetype for font rendering and UTF8-CPP to process UTF-8 files. For the databases of symbols and words it uses UTF-8 encoded XML files. The documentation can be generated by Doxygen.It is possible to write your own database in your own language in XML format.Source codeYou can find the souce code of the game here","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"https://blog.eldruin.com/tags/game/"}]}]}