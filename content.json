{"pages":[{"title":"About me","date":"2018-08-25T16:39:00.000Z","updated":"2019-11-19T07:31:02.158Z","comments":true,"path":"about/index.html","permalink":"https://blog.eldruin.com/about/index.html","excerpt":"","text":"Hi, I am a computer engineer and technical engineer in computer systems. I work at an applied research institute in Germany developing medical software in C++ and Python.Here I write mostly about programming, C++, Rust and embedded stuff.You may also know me because I wrote a japanese course for spanish speakers: Japonés por libreIf you need a Rust driver for a device or an extension to an existing driver, please feel free to contact me at eldruin [at] gmail [dot] com. We can probably find an agreement.If you want to know what I am up to, the best way is to follow me on github.SubscribingYou can also subscribe to this blog via RSS/Atom. For that you will need a reader. Here is a list.You can add this blog: blog.eldruin.com but if that does not work you can try with: https://blog.eldruin.com/atom.xml."}],"posts":[{"title":"CCS811 Indoor Air Quality Sensor Driver in Rust","slug":"/ccs811-indoor-air-quality-sensor-driver-in-rust","date":"2020-09-10T17:22:18.000Z","updated":"2020-09-11T12:06:30.000Z","comments":true,"path":"/ccs811-indoor-air-quality-sensor-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/ccs811-indoor-air-quality-sensor-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;We spend an enormous amount of time indoors. The indoor air quality is often overlooked but it is actually an important factor in our health, comfort and even productivity.There are lots of things that contribute to the degradation of the indoor air quality over time. Some of them are trivial to guess like breathing, chimneys, second-hand tobacco smoke, mold, etc. There are others that you may not have heard of like volatile organic compounds (VOC).Remember that smell new things have? well sorry but that can give you cancer.You can build your own indoor air quality monitor with an AMS/ScioSense CCS811 sensor and some Rust using the driver I wrote.The deviceThe CCS811 is an ultra-low power digital gas sensor solution which integrates a metal oxide (MOX) gas sensor to detect a wide range of Volatile Organic Compounds (VOCs) for indoor air quality monitoring with a microcontroller unit (MCU), which includes an Analog-to-Digital converter (ADC), and an I²C interface.CCS811 supports intelligent algorithms to process raw sensor measurements to output equivalent total VOC (eTVOC) and equivalent CO2 (eCO2) values, where the main cause of VOCs is from humans.CCS811 supports multiple measurement modes that have been optimized for low-power consumption during an active sensor measurement and idle mode extending battery life in portable applications.Firmware updateDepending on where you bought your device, it might be that the firmware application version is too old. I have observed the older version hangs or returns errors quite often.You can update the firmware application with a Raspberry Pi (it does not matter which one).First wire the device like this:1234567RPi &lt;-&gt; CCS811GND &lt;-&gt; GND3.3V &lt;-&gt; VCCPin 5 &lt;-&gt; SCLPin 3 &lt;-&gt; SDAGND &lt;-&gt; nWAKE3.3V &lt;-&gt; RSTNext inside your Raspberry Pi download the driver repository somewhere, then run the flashing program without arguments to print the current firmware version:123git clone https://github.com/eldruin/embedded-ccs811-rscd embedded-ccs811-rscargo run --example flash-firmwareYou will see something like this:1234Hardware ID: 129, hardware version: (1, 2)Firmware boot version: (1, 0, 0)Firmware application version: (1, 1, 0)Has valid firmware application: trueAnd then an error because no firmware file was provided.If the firmware application is smaller than (2, 0, 0), you can update it as follows.Download the new version of the firmware application from here. Then place it inside the embedded-ccs811-rs folder and call the flashing program again now providing the path to the new firmware file:1cargo run --example flash-firmware CCS811_SW000246_1-00.binYou should see an output similar to this:1234567891011Hardware ID: 129, hardware version: (1, 2)Firmware boot version: (1, 0, 0)Firmware application version: (1, 1, 0)Has valid firmware application: trueStarting update process: Reset, erase, download, verify...Update was successful!Status:Hardware ID: 129, hardware version: (1, 2)Firmware boot version: (1, 0, 0)Firmware application version: (2, 0, 0)Has valid firmware application: trueDone!Using the driverTo use the device from Rust, you have to add the embedded-ccs811 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux:123456# Cargo.toml...[dependencies]embedded-ccs811 = \"0.2\"linux-embedded-hal = \"0.3\"nb = \"1\"Here is an example program which will start the application and print the measurements (source):123456789101112131415161718192021use embedded_ccs811::&#123;prelude::*, Ccs811Awake, MeasurementMode, ModeChangeError, SlaveAddr&#125;;use linux_embedded_hal::I2cdev;use nb::block;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let sensor = Ccs811Awake::new(dev, address); match sensor.start_application() &#123; Err(ModeChangeError &#123; dev: _, error &#125;) =&gt; &#123; println!(\"Error during application start: &#123;:?&#125;\", error); &#125; Ok(mut sensor) =&gt; &#123; sensor.set_mode(MeasurementMode::ConstantPower1s).unwrap(); loop &#123; let data = block!(sensor.data()).unwrap(); println!(\"eCO2: &#123;&#125;, eTVOC: &#123;&#125;\", data.eco2, data.etvoc); &#125; &#125; &#125;&#125;Furthermore, this device must be provided with the ambient temperature and humidity in order to compensate the readings. You can see an example doing this here.I also created a bare-metal example program that runs on the STM32F1 “blue-pill” board which continuously reads the measurement and prints it on an OLED display. You can find the source code of that program here.In the driver-examples repository you can find further bare-metal examples which you can adapt to do other things with this device.Some measurementsI bought my device on AliExpress and sadly it does not seem to make accurate readings. For example if you see these readings of the device in a closed room with one person. It seems the measurements match the humidity, rather than the CO2 concentration. I made other measurements with an iAQ-Core-C sensor I got from MOUSER and these did resemble what one would expect. I will publish those here soon.Possibly my CCS811 is simply worn off. If you are interested in doing something useful with this device I would rather recommend buying it from a reputable retailer like Adafruit, Sparkfun, or so.Raspberry Pi configurationThis device uses clock stretching which leads to communication problems with the Raspberry Pi.For the firmware update it worked repeatedly fine for me but for measurement reading you may encounter errors like this:1thread &apos;main&apos; panicked at &apos;called `Result::unwrap()` on an `Err` value: Device(DeviceErrors &#123; invalid_register_write: true, invalid_register_read: true, invalid_measurement: true, max_resistance: true, heater_fault: true, heater_supply: true &#125;)&apos;, src/libcore/result.rs:1165:5You may also see this:1thread &apos;main&apos; panicked at &apos;called `Result::unwrap()` on an `Err` value: I2C(Nix(Sys(EREMOTEIO)))&apos;, src/libcore/result.rs:1165:5A trick for the Raspberry Pi is to reduce the I2C bus speed.You can do that by editing the file /boot/config.txt:12dtparam=i2c_arm=on # Enable I2Cdtparam=i2c_arm_baudrate=10000 # 10kHz speedThen reboot your Raspberry Pi. Done!Even when correctly configured the errors can happen on occasion. See here for more info.Where to go from here?There is more information and example programs in the crate documentation.If you encounter any issues, please report them in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I also have a pretty finished driver for a similar device: iAQ-Core-C/P air quality sensor. I took some measurements which looked much better. I will announce it here soon.Otherwise I have been writing many other platform-agnostic Rust drivers although I am slow to finish them up and announce them here.To see what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"Tips for hobby embedded development beginners","slug":"/tips-hobby-embedded-development-beginners","date":"2020-08-28T17:22:18.000Z","updated":"2020-09-17T19:05:02.000Z","comments":true,"path":"/tips-hobby-embedded-development-beginners/","link":"","permalink":"https://blog.eldruin.com/tips-hobby-embedded-development-beginners/","excerpt":"","text":"Somebody asked me to write these tips down so here is a very opinionated looong list of tips and hardware recommendations for hobby beginners based on my own experience.There are many alternatives to the things I mention below, and there is people with different opinions, and that is all fine.Good tools pay off and are more fun to use.SolderingGet yourself a good temperature-controlled soldering iron (or soldering station) right from the beginning. Specially if you are using lead-free solder, which I hope you are.Do not underestimate soldering fumes. That can give you even asthma.A soldering iron gets very hot. Never put it on the floor or somebody will step on it at some point. Pain ensued.Get yourself a holder where you can put the iron inside, not just leaning over it.When soldering pins to a small board, insert the pin strip into a breadboard and use another pin strip to level the module you are about to solder. That will give you straight pins. See picture above.Soldering iron tips are very important and need maintenance.Useful toolsA good wire cutter. e.g. PLATO 170.A metal helping hand tool with a magnifier.A desoldering pump.Thin straight pliers.A pair of ceramic tweezers.Useless toolsEvery-possible-shape tweezers kit.All you need is a good straight ceramic one.Wire strippers.Just cut the insulation with sharp scissors and pull it out with your fingers.Bonus tip: If it is a multicore wire, rotate the insulation as you pull it out to reduce fraying.BoardsA Raspberry Pi is one of the best things you can get. Any of them.STM32F103 boards a.k.a. “blue pill“ are incredibly cheap and popular. They are enough for many tasks and you can also use them with Arduino if you are into that. Bad clones also exist so beware.Alternatively, STM32F411 boards a.k.a. “USB-C pill“ are only slightly more expensive but the build quality and capabilities are much better.Otherwise, STM32 nucleo and especially discovery boards are great.If you are into Wi-Fi, ESP8266 boards are very cheap. ESP32 boards are more capable and also support Bluetooth. However, currently the Rust support is not as good as on other architectures.If you are into Bluetooth, the NRF52 and also NRF51 family of chips are very nice.Get yourself an STLink V2 for flashing and debugging (may be included in your board).You can use cool stuff with it like probe-rs.BreadboardingUsual jumper cables are ok but quite rigid. You can buy colored flexible silicone wire and jumper pins and housings and make your own jumper cables, which are much more pleasant to work with. About 24 AWG wire works well. See picture above.Bonus tip: make some of them slightly longer, about 30cm.30AWG “wire wrapping wire” is too thin and fragile for most uses.22AWG silicon wire is the thickest that fits into a jumper connector housing.Buy several breadboards. Otherwise you will spend a lot of time just rewiring.Bonus tip: They can be joined together.Use always the same color for the clock and data signal wires, respectively.Get yourself an “U-shaped” breadboard jumper wire kit. They are easier to follow than long cables.Bonus tip: Don’t be afraid of cutting the long ones to make several shorter ones. They are more useful and reduce clutter.With the two lines on the top and bottom of a breadboard you can transport power everywhere easily.Bonus tip: You can use one of these power rails for I2C’s SDA/SCL.SSD1306 OLED displays are very useful and cheap. You can throw then into any project.Get yourself an USB &lt;-> USART adapter. You can use it to transmit sensor data easily into your computer and communicate with many sensors and devices.Alternatively, you can use a Bluetooth &lt;-> USART adapter. e.g. HC-05.Pay attention to the voltage range of things.Get yourself a bi-directional 5V &lt;-> 3.3V logic level shifter.Beware of static electricity. It will burn your chips.Adafruit and Sparkfun have a big catalog of cool stuff, including detailed guides.You can buy lots of cool stuff very cheap at AliExpress (also eBay).However, it has its limits. Especially for quality stuff (tools, boards, solder tin) better go to your local electronics store. Also, they need more support and you can even meet people with similar interests.Remember: Good tools pay off and last longer.Buy lithium batteries only at your local electronics store or reputable retailer. They contain dangerous chemicals and can explode.Buy solder tin only at your local electronics store or reputable retailer. You do not know what is inside otherwise.If you are into robots, you can get yourself a simple robot kit so that the mechanics (motors, gearboxes, wheels) are mostly solved for you. Later you can reuse the components to build other robots.Alternatively, you can pull children toys apart. However, these are not as easy to adapt to do something else.If you must use surface-mounted chips, SOP to DIP no-soldering adapters are great for the first prototypes and are also breadboard-compatible. Furthermore, it will save you from burning the chips during soldering trying to get rid of solder bridges.Resistor, capacitor, diode and transistor kits are great if you are into electronics.A button kit and LED kit can be a lot of fun.A cheap logic analyzer can help you a lot when something does not react or acts weird. You can use it together with PulseView.Oscilloscopes are very expensive. You can build a very basic one yourself using your computer. Search for “DIY oscilloscope”.You can use prototype boards (a.k.a. protoboards) instead of making a real PCB.Alright that’s about it.Final remarksBuild cool stuff just for fun. Do not trust your wellbeing or that of your family to anything you build yourself.Validation/QA processes exist for a very good reason and that is one of the things that makes stuff more expensive.In case you missed it: Lithium batteries can explode!Be safe and have fun!","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"VEML6030/VEML7700 Ambient Light Sensor Driver in Rust","slug":"/veml6030-ambient-light-sensor-driver-in-rust","date":"2019-12-20T18:22:18.000Z","updated":"2019-12-21T08:26:30.574Z","comments":true,"path":"/veml6030-ambient-light-sensor-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/veml6030-ambient-light-sensor-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;SDC Systems contacted me about their need for a Rust driver for Vishay’s VEML6030 ambient light sensor as they had seen that I have written drivers for the VEML6075, VEML6070 and VEML6040 devices.Happy to see Rust being used commercially in an embedded application, I accepted the offer and here is the result.The devicesVishay’s VEML6030 and VEML7700 are high accuracy ambient light digital 16-bit resolution sensors in a miniature transparent package. They include a high sensitive photodiode, a low noise amplifier, a 16-bit A/D converter and support an easy to use I2C bus communication interface and additional interrupt feature.The ambient light result is as digital value available.Datasheets: VEML6030 - VEML7700Application Notes:Designing the VEML6030 into an applicationDesigning the VEML7700 into an applicationUsing the driverTo use the device from Rust, you have to add the veml6030 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux:12345# Cargo.toml...[dependencies]veml6030 = \"0.1\"linux-embedded-hal = \"0.3\"Be sure to use version 0.3 or newer of linux-embedded-hal. During development we discovered an issue with the I2C WriteRead implementation there for which I then contributed a solution.Here is an example program which will measure the ambient light in lux (source):1234567891011121314extern crate linux_embedded_hal as hal;extern crate veml6030;use veml6030::&#123;SlaveAddr, Veml6030&#125;;fn main() &#123; let dev = hal::I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut sensor = Veml6030::new(dev, address); sensor.enable().unwrap(); loop &#123; let lux = sensor.read_lux().unwrap(); println!(\"lux: &#123;:2&#125;\", lux); &#125;&#125;I also created a bare-metal example program that runs on the STM32F3Discovery board which continuously reads the measurement and prints it on an OLED display. You can find the source code of that program here.In the driver-examples repository you can find further bare-metal examples which you can adapt to do other things with this device.Originally I wrote this driver for the VEML6030 but the VEML7700 expose exactly the same interface over I2C so it is possible to use it to communicate with them as well. If doing so, you can also rename the driver struct on import with:1use veml6030::Veml6030 as Veml7700;Where to go from here?There is much more information and example programs in the crate documentation.If you encounter any issues, please report them in the issue tracker.Feedback, suggestions and improvements are gladly welcome.AcknowledgementsSpecial thanks to SDC Systems for sponsoring the development of this driver and contributing the title pictures.Thanks to my friend Dr. Daniel Cazacu for helping me with some of the math.The pictures in this post are under Copyright (C) 2019 by SDC Systems (reproduced here with permission).What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"PCA9685 PWM LED/Servo Controller Driver in Rust","slug":"/pca9685-pwm-led-servo-controller-driver-in-rust","date":"2019-12-10T14:10:15.000Z","updated":"2020-08-28T20:45:03.000Z","comments":true,"path":"/pca9685-pwm-led-servo-controller-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/pca9685-pwm-led-servo-controller-driver-in-rust/","excerpt":"","text":"PCA9685 displaying a rainbow with 2 RGB LEDs and controlling 5 servo motors. (source code)&nbsp;&nbsp;&nbsp;Today I present you a Rust driver for the PCA9685 PWM LED / Servo motor controller.The deviceThis device is an I2C-bus controlled 16-channel, 12-bit PWM controller. Its outputs can be used to control servo motors or LEDs, for example.Each channel output has its own 12-bit resolution (4096 steps) fixed frequency individual PWM controller that operates at a programmable frequency from a typical of 24 Hz to 1526 Hz with a duty cycle that is adjustable from 0% to 100%. All outputs are set to the same PWM frequency.Each channel output can be off or on (no PWM control), or set at its individual PWM controller value. The output driver is programmed to be either open-drain with a 25 mA current sink capability at 5 V or totem pole with a 25 mA sink, 10 mA source capability at 5 V. The PCA9685 operates with a supply voltage range of 2.3 V to 5.5 V and the inputs and outputs are 5.5 V tolerant. LEDs can be directly connected to the outputs (up to 25 mA, 5.5 V) or controlled with external drivers and a minimum amount of discrete components for larger current, higher voltage LEDs, etc.It is optimized to be used as an LED controller for Red/Green/Blue/Amber (RGBA) color backlighting applications.Datasheet: PCA9685Using the driverTo use the device from Rust, you have to add the pwm-pca9685 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]pwm-pca9685 = \"0.2\"linux-embedded-hal = \"0.3\"In this example we set a PWM frequency of 60 Hz and a duty cycle of 50% on channel 0 (source):1234567891011121314151617extern crate linux_embedded_hal as hal;extern crate pwm_pca9685 as pca9685;use pca9685::&#123;Channel, Pca9685, SlaveAddr&#125;;fn main() &#123; let dev = hal::I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut pwm = Pca9685::new(dev, address); // This corresponds to a frequency of 60 Hz. pwm.set_prescale(100).unwrap(); // Turn on channel 0 at 0. pwm.set_channel_on(Channel::C0, 0).unwrap(); // Turn off channel 0 at 2047, which is 50% in // the range `[0..4095]`. pwm.set_channel_off(Channel::C0, 2047).unwrap();For the title video in this post I crated an example program that runs on the STM32F1 “BluePill” board and displays the colors of the rainbow in two RGB LEDs and moves five servo motors. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"Si4703 FM Radio Receiver Driver in Rust","slug":"/si4703-fm-radio-receiver-driver-in-rust","date":"2019-12-03T18:22:18.000Z","updated":"2019-12-14T17:25:52.725Z","comments":true,"path":"/si4703-fm-radio-receiver-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/si4703-fm-radio-receiver-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;Today I present you a platform-agnostic Rust driver for the Si4703 and Si4702 FM radio receivers (turners).The devicesThe Si4702/03-C19 extends Silicon Laboratories Si4700/Si4701 FM tuner family, and further increases the ease and attractiveness of adding FM radio reception to mobile devices through small size and board area, minimum component count, flexible programmability, and superior, proven performance.The device offers significant programmability, and caters to the subjective nature of FM listeners and variable FM broadcast environments world-wide through a simplified programming interface and mature functionality.The Si4703-C incorporates a digital processor for the European Radio Data System (RDS) and the US Radio Broadcast Data System (RBDS) including all required symbol decoding, block synchronization, error detection, and error correction functions.RDS enables data such as station identification and song name to be displayed to the user. The Si4703-C offers a detailed RDS view and a standard view, allowing adopters to selectively choose granularity of RDS status, data, and block errors.Documentation:Si4702/Si4703 datasheetSi4700/01/02/03 Programmer’s GuideUsing RDS/RBDS with the Si4701/03Si47xx Programming GuideUsing the driverTo use the device from Rust, you have to add the si4703 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):123456# Cargo.toml...[dependencies]si4703 = \"0.1\"linux-embedded-hal = \"0.3\"nb = \"0.1\"Here is an example program which will seek to the first FM channel available and print it (source):123456789101112131415161718192021222324252627282930313233343536use embedded_hal::blocking::delay::DelayMs;use linux_embedded_hal::&#123;Delay, I2cdev, Pin&#125;;use nb::block;use si4703::&#123; reset_and_select_i2c_method1, ChannelSpacing, DeEmphasis, SeekDirection, SeekMode, Si4703, Volume,&#125;;fn main() &#123; let mut delay = Delay &#123;&#125;; &#123; // Reset and communication protocol selection must be done beforehand let mut sda = Pin::new(2); let mut rst = Pin::new(17); reset_and_select_i2c_method1(&amp;mut rst, &amp;mut sda, &amp;mut delay).unwrap(); &#125; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let mut radio = Si4703::new(dev); radio.enable_oscillator().unwrap(); // Wait for the oscillator to stabilize delay.delay_ms(500_u16); radio.enable().unwrap(); // Wait for powerup delay.delay_ms(110_u16); radio.set_volume(Volume::Dbfsm28).unwrap(); radio.set_deemphasis(DeEmphasis::Us50).unwrap(); radio.set_channel_spacing(ChannelSpacing::Khz100).unwrap(); radio.unmute().unwrap(); let stc_int = Pin::new(27); // Seek using STC interrupt pin block!(radio.seek_with_stc_int_pin(SeekMode::Wrap, SeekDirection::Up, &amp;stc_int)).unwrap(); let channel = radio.channel().unwrap_or(-1.0); println!(\"Found channel at &#123;:1&#125; MHz\", channel);&#125;I also created an example program that runs on the STM32F1 “BluePill” board which seeks an FM channel forward or backwards when pressing a button and prints it on an OLED display (the one in the title picture). You can find the source code here.In the driver-examples repository you can find bare-metal examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.If you encounter any issues, please report them in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"OPT300x Ambient Light Sensor Driver in Rust","slug":"/opt300x-ambient-light-sensor-driver-in-rust","date":"2019-11-09T16:22:18.000Z","updated":"2019-12-14T17:28:52.007Z","comments":true,"path":"/opt300x-ambient-light-sensor-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/opt300x-ambient-light-sensor-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;Today I present you a platform-agnostic Rust driver for the OPT300x family of ambient light sensors.The OPT3001, for example, can be found on the TI CC2650STK SensorTag board.The devicesThis driver is compatible with the devices OPT3001, OPT3002, OPT3004, OPT3006 and OPT3007.The OPT3001 is a sensor that measures the intensity of visible light. The spectral response of the sensor tightly matches the photopic response of the human eye and includes significant infrared rejection.The OPT3001 is a single-chip lux meter, measuring the intensity of light as visible by the human eye. The precision spectral response and strong IR rejection of the device enables the OPT3001 to accurately meter the intensity of light as seen by the human eye regardless of light source. The strong IR rejection also aids in maintaining high accuracy when industrial design calls for mounting the sensor under dark glass for aesthetics. The OPT3001 is designed for systems that create light-based experiences for humans, and an ideal preferred replacement for photodiodes, photoresistors, or other ambient light sensors with less human eye matching and IR rejection.Measurements can be made from 0.01 lux up to 83k lux without manually selecting full-scale ranges by using the built-in, full-scale setting feature. This capability allows light measurement over a 23-bit effective dynamic range.The digital operation is flexible for system integration. Measurements can be either continuous or single-shot. The control and interrupt system features autonomous operation, allowing the processor to sleep while the sensor searches for appropriate wake-up events to report via the interrupt pin. The digital output is reported over an I2C- and SMBus-compatible, two-wire serial interface.The low power consumption and low power-supply voltage capability of the OPT3001 enhance the battery life of battery-powered systems.Datasheets: OPT3001, OPT3002, OPT3004, OPT3006, OPT3007Application Guide: OPT3001 ALS Application GuideUsing the driverTo use the device from Rust, you have to add the opt300x crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]opt300x = \"0.1\"linux-embedded-hal = \"0.3\"Here is an example program which will measure the ambient light in lux and print it (source):1234567891011121314extern crate linux_embedded_hal as hal;extern crate opt300x;use opt300x::&#123;Opt300x, SlaveAddr&#125;;fn main() &#123; let dev = hal::I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let sensor = Opt300x::new_opt3001(dev, address); let mut sensor = sensor.into_continuous().ok().unwrap(); loop &#123; let lux = sensor.read_lux().unwrap(); println!(\"lux: &#123;:2&#125;\", lux); &#125;&#125;I also created an example program that runs on the STM32F1 “BluePill” board which continuously reads the me measurement and prints it on an OLED display. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"VEML6075 UVA and UVB Light Sensor Driver in Rust","slug":"/veml6075-uva-uvb-uv-index-light-sensor-driver-in-rust","date":"2019-09-28T09:22:18.000Z","updated":"2020-08-28T08:25:13.000Z","comments":true,"path":"/veml6075-uva-uvb-uv-index-light-sensor-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/veml6075-uva-uvb-uv-index-light-sensor-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;Today I present you a platform-agnostic rust driver for the VEML6075 UVA and UVB light sensor.With this device you can also calculate the UV index.The deviceThe VEML6075 senses UVA and UVB light and incorporates photodiode, amplifiers, and analog / digital circuits into a single chip using a CMOS process. When the UV sensor is applied, it is able to detect UVA and UVB intensity to provide a measure of the signal strength as well as allowing for UVI measurement.The VEML6075 provides excellent temperature compensation capability for keeping the output stable under changing temperature. VEML6075’s functionality is easily operated via the simple command format of I2C (SMBus compatible) interface protocol.VEML6075’s operating voltage ranges from 1.7 V to 3.6 V.Datasheet: VEML6075Application note: Designing the VEML6075 into an ApplicationUsing the driverTo use the device from Rust, you have to add the veml6075 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]veml6075 = \"0.2\"linux-embedded-hal = \"0.3\"Here is an example program which will read the UVA, UVB and calculated UV index (source):12345678910extern crate linux_embedded_hal as hal;extern crate veml6075;use veml6075::&#123;Calibration, Veml6075&#125;;fn main() &#123; let dev = hal::I2cdev::new(\"/dev/i2c-1\").unwrap(); let mut sensor = Veml6075::new(dev, Calibration::default()); let m = sensor.read().unwrap(); println!(\"UVA: &#123;:2&#125;, UVB: &#123;:2&#125;, UVI: &#123;:2&#125;\", m.uva, m.uvb, m.uv_index);&#125;I also created an example program that runs on the STM32F3Discovery board which continuously reads the measurement and prints it on an OLED display. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"MCP794xx Real-Time Clock (RTC) / Calendar Driver in Rust","slug":"/mcp794xx-real-time-clock-rtc-driver-in-rust","date":"2019-09-15T10:22:17.000Z","updated":"2019-12-14T17:28:39.602Z","comments":true,"path":"/mcp794xx-real-time-clock-rtc-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/mcp794xx-real-time-clock-rtc-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;Today I present you a platform-agnostic rust driver for the MCP794xx family of real-time clock / calendar devices compatible with MCP7940N, MCP7940M, MCP79400, MCP79401, MCP79402, MCP79410, MCP79411 and MCP79412.If you are reading this you probably know about monotron, the 1980’s home computer style application written in Rust by Jonathan Pallant.He has now designed a dedicated PCB for it including an MCP7940N RTC which did not have a Rust driver so here it is.The devicesThe Real-Time Clock/Calendar (RTCC) tracks time using internal counters for hours, minutes, seconds, days, months, years, and day of week. Alarms can be configured on all counters up to and including months. For usage and configuration, the devices support I2C communications up to 400 kHz.The open-drain, multi-functional output can be configured to assert on an alarm match, to output a selectable frequency square wave, or as a general purpose output.The devices are designed to operate using a 32.768 kHz tuning fork crystal with external crystal load capacitors. On-chip digital trimming can be used to adjust for frequency variance caused by crystal tolerance and temperature.SRAM and timekeeping circuitry are powered from the back-up supply when main power is lost, allowing the device to maintain accurate time and the SRAM contents. The times when the device switches over to the back-up supply and when primary power returns are both logged by the power-fail time-stamp.Some of the devices feature 1 Kbit of internal non-volatile EEPROM with software write-protectable regions. There is an additional 64 bits of protected non-volatile memory which is only writable after an unlock sequence, making it ideal for storing a unique ID or other critical information.Some of the devices offer a pre-programmed with EUI-48 and EUI-64 addresses. Custom programming is also available.Datasheets:MCP7940NMCP7940MMCP79400/MCP79401/MCP79402MCP79410/MCP79411/MCP79412Using the driverTo use the device from Rust, you have to add the mcp794xx crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]mcp794xx = \"0.1\"linux-embedded-hal = \"0.3\"Here is an example program which will set a date and time and read back the seconds later on (source):12345678910111213141516171819202122232425262728extern crate embedded_hal;extern crate linux_embedded_hal;extern crate mcp794xx;use linux_embedded_hal::I2cdev;use mcp794xx::&#123;DateTime, Hours, Mcp794xx, Rtcc&#125;;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let mut rtc = Mcp794xx::new_mcp7940n(dev); rtc.enable().unwrap(); let datetime = DateTime &#123; year: 2019, month: 9, day: 15, weekday: 7, hour: Hours::H24(11), minute: 59, second: 58, &#125;; rtc.set_datetime(&amp;datetime).unwrap(); rtc.enable().unwrap(); // do something else... let seconds = rtc.get_seconds().unwrap(); println!(\"Seconds: &#123;&#125;\", seconds); let _dev = rtc.destroy();&#125;I also created an example program that runs on the STM32F3Discovery board which continuously reads the date and time and prints it on an OLED display. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"AD9833/AD9837 Waveform Generator / DDS Driver in Rust","slug":"/ad983x-waveform-generator-dds-driver-in-rust","date":"2019-05-29T16:10:15.000Z","updated":"2019-12-14T17:27:35.679Z","comments":true,"path":"/ad983x-waveform-generator-dds-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/ad983x-waveform-generator-dds-driver-in-rust/","excerpt":"","text":"Simple MIDI player playing Beethoven's Ninth Symphony. (source code)&nbsp;&nbsp;&nbsp;Today I present you an waveform generator / direct digital synthesizer (DDS) Rust driver compatible with the devices AD9833 and AD9837 (more in the future).The devicesThe AD9833 and AD9837 are low power, programmable waveform generators capable of producing sine, triangular, and square wave outputs. Waveform generation is required in various types of sensing, actuation, and time domain reflectometry (TDR) applications. The output frequency and phase are software programmable, allowing easy tuning. No external components are needed. The frequency registers are 28 bits wide: with a 25 MHz clock rate, resolution of 0.1 Hz can be achieved; with a 1 MHz clock rate, the AD9833 can be tuned to 0.004 Hz resolution.The AD9833 and AD9837 are written to via a 3-wire serial interface (SPI).Using the driverTo use the device from Rust, you have to add the ad983x crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]ad983x = \"0.1\"linux-embedded-hal = \"0.3\"This is an example program which will generate a 440 Hz sinus wave given a 25 MHz clock which corresponds to a standard A4 tone (source):1234567891011121314151617181920extern crate ad983x;extern crate linux_embedded_hal;use ad983x::&#123;Ad983x, FrequencyRegister&#125;;use linux_embedded_hal::&#123;Pin, Spidev&#125;;fn main() &#123; let spi = Spidev::open(\"/dev/spidev0.0\").unwrap(); let chip_select = Pin::new(25); let mut dds = Ad983x::new_ad9833(spi, chip_select); dds.reset().unwrap(); dds.set_frequency(FrequencyRegister::F0, 4724).unwrap(); dds.enable().unwrap(); // Given a 25 MHz clock, this now outputs a sine wave // with a frequency of 440 Hz, which is a standard // A4 tone. // Get SPI device and CS pin back let (_spi, _chip_select) = dds.destroy();&#125;I also created a simple MIDI player example program that runs on the STM32F1 “BluePill” board and plays the last part of Beethoven’s Ninth Symphony. That is the program running in the title video. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"KXCJ9/KXCJB Tri-Axis MEMS Accelerometer Driver in Rust","slug":"/kxcj9-kxcjb-tri-axis-mems-accelerator-driver-in-rust","date":"2019-05-11T08:22:17.000Z","updated":"2019-12-14T17:28:24.828Z","comments":true,"path":"/kxcj9-kxcjb-tri-axis-mems-accelerator-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/kxcj9-kxcjb-tri-axis-mems-accelerator-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;Not long ago I discovered an interesting project by Sergey Matyukevich to create a custom firmware for a robot vacuum cleaner in Rust.While I do not own one of these robots, I saw that he would need a driver for the KXCJ9 accelerometer and offered to write it.The result is what I present you today. A platform-agnostic rust driver for the KXCJ9 and KXCJB accelerometers.Quiz question: Can you locate the accelerometer in the image above?The devicesThe KXCJ9 is a high-performance, ultra-low-power, tri-axis accelerometer designed for mobile applications. It offers our best power performance along with an embedded wake-up feature, Fast-mode I²C and up to 14-bit resolution. The KXCJ9 sensor offers improved shock, reflow, and temperature performance, and the ASIC has internal voltage regulators that allow operation from 1.8 V to 3.6 V within the specified product performance.The KXCJB is the thinnest tri-axis accelerometer available on the market today. This ultra-thin 3x3x0.45mm low-power accelerometer is also one of our most full-featured products. The KXCJB offers up to 14-bit resolution for greater precision. User-selectable parameters include ± 2g, 4g or 8g ranges and Output Data Rates (ODR) with programmable low-pass filter. The KXCJB also features the Kionix XAC sense element, our most advanced sense element, for outstanding stability over temperature, shock and post-reflow performance.The communication is done through an I2C bidirectional bus.Using the driverTo use the device from Rust, you have to add the kxcj9 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]kxcj9 = \"0.2\"linux-embedded-hal = \"0.3\"This is an example program which will measure the acceleration on the axes and print it (in G) (source):1234567891011121314extern crate kxcj9;extern crate linux_embedded_hal as hal;use kxcj9::&#123;Kxcj9, SlaveAddr&#125;;fn main() &#123; let dev = hal::I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut sensor = Kxcj9::new_kxcj9_1018(dev, address); sensor.enable().unwrap(); loop &#123; let acc = sensor.read().unwrap(); println!(\"X: &#123;:2&#125;, Y: &#123;:2&#125;, Z: &#123;:2&#125;\", acc.x, acc.y, acc.z); &#125;&#125;I also created an example program that runs on the STM32F3Discovery board which continuously reads the acceleration and transmits the reading per USART. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.AcknowledgementsThanks to Kionix engineers for precisely answering my questions and also Sergey Matyukevich for providing the title image.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - DocumentationQuiz solution: The accelerometer is the small square chip located down-right from the main MCU (the big chip).","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"Ads1x1x Analog-to-Digital Converter Driver in Rust","slug":"/ads1x1x-analog-to-digital-converter-driver-in-rust","date":"2019-03-31T12:22:17.000Z","updated":"2019-12-14T17:27:50.859Z","comments":true,"path":"/ads1x1x-analog-to-digital-converter-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/ads1x1x-analog-to-digital-converter-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;Today I present you an analog-to-digital converter (ADC) Rust driver compatible with the devices ADS1013, ADS1014, ADS1015, ADS1113, ADS1114 and ADS1115.The devicesThe devices are precision, low power, 12/16-bit analog-to-digital converters (ADC) that provide all features necessary to measure the most common sensor signals in an ultra-small package. Depending on the device, these integrate a programmable gain amplifier (PGA), voltage reference,oscillator and high-accuracy temperature sensor.The devices can perform conversions at data rates up to 3300 samples per second (SPS). The PGA offers input ranges from ±256 mV to ±6.144 V, allowing both large and small signals to be measured with high resolution. An input multiplexer (MUX) allows to measure two differential or four single-ended inputs. The high-accuracy temperature sensor can be used for system-level temperature monitoring or cold-junction compensation for thermocouples.The devices operate either in continuous-conversion mode, or in a single-shot mode that automatically powers down after a conversion. Single-shot mode significantly reduces current consumption during idle periods. Data is transferred through I2C.You can buy a module board containing this from AliExpress or eBay.Using the driverTo use the device from Rust, you have to add the ads1x1x crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]ads1x1x = \"0.2\"linux-embedded-hal = \"0.3\"Voltage divider exampleIn the title picture in this post I created a voltage divider circuit using 3 resistors of equal value and connected the points in the divider to the inputs of the ADC.A voltage divider is a circuit that can “divide” the voltage and output a voltage in between,proportional to the resistences in place.Here is the circuit schematic:The resistor values do not matter much but it is nicer to understand if they are all of the same value.With this setup we should get the reading for +5V on channel A0, the reading for GND on channel A3 and A1 and A2 equally spaced in between (within resistence tolerances).I get these values:Channel 0: 1575Channel 1: 1051Channel 2: 524Channel 3: 0We can calculate the relations and voltage that correspond to each channel if weassume that 1575 corresponds to 5V.ChannelFactorVoltage01575 / 1575=1* 5V=5V11051 / 1575=0.667* 5V=3.34V2524 / 1575=0.333* 5V=1.66V30 / 1575=0* 5V=0VAs you can see, the voltage was divided equally by all resistors.The program1234567891011121314151617181920212223242526extern crate embedded_hal;use embedded_hal::adc::OneShot;extern crate linux_embedded_hal;#[macro_use(block)]extern crate nb;extern crate ads1x1x;use ads1x1x::&#123;channel, Ads1x1x, SlaveAddr&#125;;use linux_embedded_hal::I2cdev;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut adc = Ads1x1x::new_ads1015(dev, address); let values = [ block!(adc.read(&amp;mut channel::SingleA0)).unwrap(), block!(adc.read(&amp;mut channel::SingleA1)).unwrap(), block!(adc.read(&amp;mut channel::SingleA2)).unwrap(), block!(adc.read(&amp;mut channel::SingleA3)).unwrap(), ]; for (channel, value) in values.iter().enumerate() &#123; println!(\"Channel &#123;&#125;: &#123;&#125;\", channel, value); &#125; // get I2C device back let _dev = adc.destroy_ads1015();&#125;This example is also available in the crate sources here.In the title picture you can see this running on the STM32F3Discovery board and printing the results on an OLED display. You can find the application souce code here.In the driver-examples repository you can find further examples of using these devices like measuring the output of a digital potentiometer (digipot) and a digital-to-analog converter (DAC).Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"TMP1x2 Temperature Sensor Driver in Rust","slug":"/tmp1x2-temperature-sensor-driver-in-rust","date":"2019-03-17T09:22:17.000Z","updated":"2019-12-14T17:29:20.062Z","comments":true,"path":"/tmp1x2-temperature-sensor-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/tmp1x2-temperature-sensor-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;I have continued writing several Rust device drivers. Today I present you a Rust driver for the TMP102 and TMP112 high-accuracy, low-power, digital temperature sensors.The devicesThis driver is compatible with both the TMP102 device as well as the TMP112 family of devices, including TMP112A, TMP112B and TMP112N.These temperature sensors are highly linear and do not require complex calculations or lookup tables to derive the temperature. The on-chip 12-bit ADC offers resolutions down to 0.0625°C.The TMP102 device is a digital temperature sensor ideal for NTC/PTC thermistor replacement where high accuracy is required. The device offers an accuracy of +/-0.5°C without requiring calibration or external component signal conditioning.The TMP112 family of devices are digital temperature sensors designed for high-accuracy, low-power, NTC/PTC thermistor replacements where high accuracy is required. The TMP112A and TMP112B offers 0.5°C accuracy and are optimized to provide the best PSR performance for 3.3V and 1.8V operation respectively, while TMP112N offers 1°C accuracy.The communication is done serially through an I²C, bidirectional bus.Datasheets: TMP102, TMP112xYou can buy a module board containing this from AliExpress or eBay.Using the driverTo use the device from Rust, you have to add the tmp1x2 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]tmp1x2 = \"0.2\"linux-embedded-hal = \"0.3\"This is an example program which will measure the temperature and print it (in Celsius) (source):123456789101112extern crate linux_embedded_hal as hal;extern crate tmp1x2;use tmp1x2::&#123;SlaveAddr, Tmp1x2&#125;;fn main() &#123; let dev = hal::I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut sensor = Tmp1x2::new(dev, address); let temperature = sensor.read_temperature().unwrap(); println!(\"Temperature: &#123;:.1&#125;ºC\", temperature);&#125;I also created an example program that runs on the STM32F3Discovery board which continuously measures the temperature and prints it on an OLED display. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have been writing many other platform-agnostic Rust drivers although I am slow to announce them here. If you want to know what I am currently working on you can follow me on github.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"TMP006 Contact-less Infrared (IR) Thermopile Temperature Sensor Driver in Rust","slug":"/tmp006-contact-less-infrared-ir-thermopile-driver-in-rust","date":"2018-12-07T17:22:17.000Z","updated":"2019-12-14T17:29:41.092Z","comments":true,"path":"/tmp006-contact-less-infrared-ir-thermopile-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/tmp006-contact-less-infrared-ir-thermopile-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;I have been writing several platform-agnostic Rust drivers (15 published at the moment) as a way to push embedded development in Rust forward. Today I present you a Rust driver for the TMP006.The TMP006 is a pretty cool device that can measure the temperature of an object without touching it. An infrared thermopile.The devicesThe TMP006 and TMP006B are the first in a series of temperature sensors that measure the temperature of an object without the need to make contact with the object. This sensor uses a thermopile to absorb the infrared energy emitted from the object being measured and uses the corresponding change in thermopile voltage to determine the object temperature.Infrared sensor voltage range is specified from -40°C to +125°C to enable use in a wide range of applications. Low power consumption along with low operating voltage makes the device suitable for battery-powered applications. The low package height of the chip-scale format enables standard high- volume assembly methods, and can be useful where limited spacing to the object being measured is available.The communication is done serially through an I²C, bidirectional bus.Datasheet: TMP006/BUser guide: TMP006 user guideYou can buy this from Adafruit or AliExpress.The driverThis driver allows you to:Enable/disable the device. See: enable().Read the object temperature. See: read_object_temperature().Read the object voltage and ambient temperature raw data. See: read_sensor_data().Calculate the object temperature from the sensor raw data. See: calculate_object_temperature().Set the ADC conversion rate. See: set_conversion_rate().Enable/disable the DRDY pin. See: enable_drdy_pin().Read whether data is ready to be read. See: is_data_ready().Perform a software reset. See: reset().Read the manufacturer ID. See: read_manufacturer_id().Read the device ID. See: read_device_id().Using the driverTo use the device from Rust, you have to add the tmp006 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]tmp006 = \"0.2\"linux-embedded-hal = \"0.3\"This is an example program which will measure the temperature and print it (in Kelvins) (source):12345678910111213141516extern crate linux_embedded_hal as hal;extern crate tmp006;use hal::I2cdev;use tmp006::&#123;Tmp006, SlaveAddr&#125;;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let address = SlaveAddr::default(); let mut sensor = Tmp006::new(dev, address); let calibration_factor = 6e-14; let temperature = sensor .read_object_temperature(calibration_factor) .unwrap(); println!(\"Temperature: &#123;&#125;K\", temperature);&#125;I also created an example program that runs on the STM32F3Discovery board which continuously measures the temperature and prints it on an OLED display. You can find the application source code here.In the driver-examples repository you can find further examples which you can adapt to do other things with this device.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?As I said, I have been writing several platform-agnostic Rust drivers (15 published at the moment) and will announce them here soon.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"DS1307 Real-Time Clock (RTC) Driver in Rust","slug":"/ds1307-real-time-clock-rtc-driver-in-rust","date":"2018-09-24T17:25:37.000Z","updated":"2019-12-14T17:28:11.070Z","comments":true,"path":"/ds1307-real-time-clock-rtc-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/ds1307-real-time-clock-rtc-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;After writing the 24x Serial EEPROM IC driver I have written a driver for the DS1307 real-time clock as part of the Weekly Driver Initiative. This platform-agnostic driver is based on embedded-hal.Modules containing this IC often come often together with a button battery holder like in the picture above and an AT24C32 EEPROM (Electrically Erasable and Programmable Read-Only Memory) IC. Please refer to the 24x Serial EEPROM IC driver to use that IC.I wrote this driver following Test-Driven-Development using the embedded-hal-mock crate which was very helpful.The deviceThe DS1307 serial real-time clock (RTC) is a low-power, full binary-coded decimal (BCD) clock/calendar plus 56 bytes of NV SRAM. Address and data are transferred serially through an I²C, bidirectional bus.The clock/calendar provides seconds, minutes, hours, day, date, month, and year information. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap year. The clock operates in either the 24-hour or 12-hour format with AM/PM indicator.The DS1307 has a built-in power-sense circuit that detects power failures and automatically switches to the backup supply. Timekeeping operation continues while the part operates from the backup supply.Datasheet: DS1307In this blog post I will use a module similar to the one in the picute. You can buy the device on AliExpress or eBay for a few cents.The driverThis driver allows you to:Read and set date and time in 12-hour and 24-hour format. See: get_datetimeEnable and disable the real-time clock. See: set_runningRead and write user RAM. See: read_ramControl square-wave output. See: enable_square_wave_outputUsing the driverTo use the device from Rust, you have to add the ds1307 crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]ds1307 = \"0.2\"linux-embedded-hal = \"0.3\"This is an example program which will set the date and time and then read it back:123456789101112131415161718192021222324252627282930313233343536373839extern crate linux_embedded_hal as hal;extern crate ds1307;use hal::I2cdev;use ds1307::&#123;DS1307, DateTime, Hours&#125;;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let mut rtc = DS1307::new(dev); let datetime = DateTime &#123; year: 2018, month: 08, day: 15, weekday: 4, hour: Hours::H24(19), minute: 59, second: 58 &#125;; rtc.set_datetime(&amp;datetime).unwrap(); let datetime = rtc.get_datetime().unwrap(); // The hours depend on the RTC running mode. match datetime.hour &#123; Hours::H24(h) =&gt; println!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;, &#123;&#125; &#123;&#125;:&#123;&#125;:&#123;&#125;\", datetime.year, datetime.month, datetime.day, datetime.weekday, h, datetime.minute, datetime.second), Hours::AM(h) =&gt; println!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;, &#123;&#125; &#123;&#125;:&#123;&#125;:&#123;&#125; AM\", datetime.year, datetime.month, datetime.day, datetime.weekday, h, datetime.minute, datetime.second), Hours::PM(h) =&gt; println!(\"&#123;&#125;-&#123;&#125;-&#123;&#125;, &#123;&#125; &#123;&#125;:&#123;&#125;:&#123;&#125; PM\", datetime.year, datetime.month, datetime.day, datetime.weekday, h, datetime.minute, datetime.second), &#125; // This will print something like: 2018-08-15, 4 19:59:58&#125;This example is also available in the crate sources here.The driver also allows individual access to the year, month, day, etc. through functions like:set_year(), get_year() and so on.Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have a WIP driver for the popular I/O expanders PCF8574, PCF8574A and PCF8575 and another WIP one for the TCA9548A and PCA9548A I2C switches/multiplexers. I will announce them here soon.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"24x Serial EEPROM ICs driver in Rust","slug":"/24x-serial-eeprom-driver-in-rust","date":"2018-09-09T11:49:37.000Z","updated":"2019-12-14T17:27:19.660Z","comments":true,"path":"/24x-serial-eeprom-driver-in-rust/","link":"","permalink":"https://blog.eldruin.com/24x-serial-eeprom-driver-in-rust/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;I have been learning Rust on and off for quite a while and embedded systems have always been interesting for me.At some point I discovered the Discovery book and decided to turn back to the embedded fun I did not touch since my childhood.After completing the book I was looking for something useful to do and wrote this driver for the common 24x Serial EEPROM IC series as part of the Weekly Driver Initiative. This platform-agnostic driver is based on embedded-hal.I wrote this driver following Test-Driven-Development using the embedded-hal-mock crate which was very helpful.The devicesThe devices are serial EEPROM (Electrically Erasable and Programmable Read-Only Memory) ICs, with different capacities, which communicate using I²C. With these devices it is possible to store data which will persist on the absence of power.There are many vendors that have compatible ICs on their portfolios and seem to have a common “24“ family name, hence the name of the driver.For example, Microchip has ICs like AT24C32, 24AA32A and AT24C256 whereas STMicroelectronics has ICs like M24C32.There may also be other vendors that have compatible ICs under a different name. If you know of some of these, please let me know and I will add them to the list of compatible devices.This driver attempts to be compatible with many of these ICs.In this blog post I will use the AT24C256C. You can buy the device on AliExpress or eBay for a few cents.There are also many Real-Time-Clock (RTC) modules, typically for Arduino, that include an RTC IC like the DS1307 and also an AT24C32 EEPROM IC so you may already have an EEPROM IC that you can use.The driverThis driver allows you to:Read a single byte from a memory address. See: read_byteRead a byte array starting on a memory address. See: read_dataRead the current memory address (please read notes). See: read_current_addressWrite a byte to a memory address. See: write_byteWrite a byte array (up to a memory page) to a memory address. See: write_pageCan be used at least with the devices AT24C32, AT24C64, AT24C128, AT24C256 and AT24C512.Using the driverTo use the device from Rust, you have to add the eeprom24x crate to your project as well as a concrete implementation of the embedded-hal traits. For example if you are using the Raspberry Pi running Linux (see driver-examples for bare-metal hardware):12345# Cargo.toml...[dependencies]eeprom24x = \"0.1\"linux-embedded-hal = \"0.3\"This is an example program writing and reading some data from the memory (source):1234567891011121314151617181920212223extern crate embedded_hal;extern crate linux_embedded_hal;extern crate eeprom24x;use embedded_hal::blocking::delay::DelayMs;use linux_embedded_hal::&#123;I2cdev, Delay&#125;;use eeprom24x::&#123;Eeprom24x, SlaveAddr&#125;;fn main() &#123; let dev = I2cdev::new(\"/dev/i2c-1\").unwrap(); let mut eeprom = Eeprom24x::new_24x256(dev, SlaveAddr::default()); let memory_address = [0x12, 0x34]; let data = 0xAB; eeprom.write_byte(&amp;memory_address, data).unwrap(); Delay.delay_ms(5u16); let retrieved_data = eeprom.read_byte(&amp;memory_address).unwrap(); println!(\"Read memory address: [&#123;&#125;,&#123;&#125;], retrieved content: &#123;&#125;\", memory_address[0], memory_address[1], &amp;retrieved_data);&#125;Where to go from here?There is much more information and example programs in the crate documentation.Please give this driver a try and report any issues you may encounter in the issue tracker.Feedback, suggestions and improvements are gladly welcome.What’s next?I have a driver for the popular DS1307 real-time clock (RTC) and a WIP driver for the popular I/O expanders PCF8574, PCF8574A and PCF8575. I will announce them here soon.Thanks for reading and stay tuned!Links: Source code - Crate - Documentation","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"},{"name":"rust","slug":"embedded/rust","permalink":"https://blog.eldruin.com/categories/embedded/rust/"}],"tags":[{"name":"rust","slug":"rust","permalink":"https://blog.eldruin.com/tags/rust/"},{"name":"driver","slug":"driver","permalink":"https://blog.eldruin.com/tags/driver/"},{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"}]},{"title":"OSEater","slug":"/oseater","date":"2012-02-05T14:04:48.000Z","updated":"2018-09-02T10:25:02.000Z","comments":true,"path":"/oseater/","link":"","permalink":"https://blog.eldruin.com/oseater/","excerpt":"","text":"OSEater is a “Pac-Man”-style game in which “Tux”, the Linux pet, has to collect all the dots in the map avoiding the Windows logos.Apple logos also exist and when they are eaten by Tux the game mode is changed and the hero can eat the Windows logos.Platform:It is developed for the nice LPC2378-STK board from Olimex, based on the LPC2378 microcontroller from NXP which has an ARM architecture.The peripherals used are the built in screen, joystick and digital to analog converter to play sounds.It is developed under an evaluation version of CrossWorks for GNU/Linux and was developed for the subject “Microcontrollers and microprocessors” of the university in aproximately 1 month.Design:OSEater follows an object oriented design using a component-based metodology in C++ programming language.Due to the strong hardware limitations and the short development time, the code is not as beautiful as it could be.Many thanks to my teacher Víctor Manuel Sánchez Corbacho for the development of the low-level interface for the board (which I cleaned up, translated and released as libOlimex-LPC2378-STK), to the freesound.org project and to the user HardPCM for creating the sounds I have used in this game.Source codeYou can find the full source code on GitHub.Low-level board interface library: libOlimex-LPC2378-STK","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"https://blog.eldruin.com/tags/game/"}]},{"title":"Sound2Header","slug":"/sound2header","date":"2012-01-28T18:04:48.000Z","updated":"2018-09-02T10:25:08.000Z","comments":true,"path":"/sound2header/","link":"","permalink":"https://blog.eldruin.com/sound2header/","excerpt":"","text":"Sound2Header (sound to header) is a little and simple C program that I have written using the libsndfile library to convert any sound file supported by libsndfile to an array of samples in a range given in the command line and write the result to a header file.The generated header file can be included in any C/C++ souce code file. It is intended for embedded projects where it is not possible to open files like when there is an operative system in place.Sound2Header is free software licensed under the GNU/GPL version 3 or later license. It can be easily compiled with make if you download the tarball from Github with:1makeor executing:1gcc -lsndfile sound2header.c -o sound2header(you need to have the libsndfile library installed, libsndfile-dev package in ubuntu)Many thanks to Erik de Castro Lopo for creating and mantaining the libsndfile library.Source codeRepository on Github: here","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"https://blog.eldruin.com/tags/game/"}]},{"title":"Inter-Process Communication: pipe(), fork() and C++ STL-like streams","slug":"/inter-process-communication-pipe-fork-cpp-stl-like-streams","date":"2011-04-22T07:04:48.000Z","updated":"2018-09-02T10:24:54.000Z","comments":true,"path":"/inter-process-communication-pipe-fork-cpp-stl-like-streams/","link":"","permalink":"https://blog.eldruin.com/inter-process-communication-pipe-fork-cpp-stl-like-streams/","excerpt":"","text":"I’ve run into some troubles lately trying to communicate processes through C++ STL-like streams with fork() and pipe() so I’ve created an example of how can this be done in a POSIX environment using the GCC’s libstdc++ (GCC &gt;= 3.4.0).The scenario is: A parent process wants to handle another program’s input and output streams, a process-level wrapper.So the example is: A parent process forks into another child process. The parent sends the child a message, the child receives it and outputs it to the parent to show the communication works just fine.The forked process calls the program we want to control. Which in this case is the easiest C++ program ever: Just reads a line from the standard input and outputs a message containing the line just read through the standard output. In addition, another message is sent through the standard error stream.Controlled programLet’s see the code for the controlled program:1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; string message; getline(cin, message); cout &lt;&lt; \"Program: I've received: \" &lt;&lt; \"'\" &lt;&lt; message &lt;&lt; \"'\" &lt;&lt; endl; cerr &lt;&lt; \"Program: This is the error stream!\" &lt;&lt; endl; return (0);&#125;As you can see we use the standard input/output streams cin, cout and cerr.Main ProgramNow let’s see chunks of the main program:123456789101112131415#define CHILD_STDIN_READ pipefds_input[0]#define CHILD_STDIN_WRITE pipefds_input[1]int pipefds_input[2], pipefds_output[2], pipefds_error[2];// Create the pipes// We do this before the fork so both processes will know about// the same pipe and they can communicate.pipe_status = pipe(pipefds_input);if (pipe_status == -1)&#123; perror(\"Error creating the pipe\"); exit(EXIT_FAILURE);&#125;With the definitions you won’t mistake the pipe ends.We repeat the same process for the pipes for standard output and error.fork() skeleton1234567891011121314151617pid_t pid;pid = fork();if (pid == pid_t(0))&#123; // Child process&#125;else if (pid &gt; pid_t(0))&#123; // Parent&#125;else&#123; // Error: fork failed&#125;// Shared codeThis is the skeleton for a fork(). When you call fork() a new process is created in memory and the pid return value is set to two different values in each process.Standard streams tying1234567891011121314// Child Process// Tie the standard input, output and error streams to the// appropiate pipe ends// The file descriptor 0 is the standard input// We tie it to the read end of the pipe as we will use// this end of the pipe to read from it// Same for the othersdup2 (CHILD_STDIN_READ,0);dup2 (CHILD_STDOUT_WRITE,1); // standard outputdup2 (CHILD_STDERR_WRITE,2); // standard error// Close in the child the unused ends of the pipesclose(CHILD_STDIN_WRITE);close(CHILD_STDOUT_READ);close(CHILD_STDERR_READ);In each process we only use one end of the pipes, this is, in the child, we only read from stdin and only write to stdout and stderr. So we close the other ends.We do the same in the parent process, but don’t need to tie anything this time.exec()In the child we execute the program to be controlled through execl()123// Child// Execute the programexecl(\"./program\", \"program\", (char*)NULL);When you call exec(), the called program replaces the executing program, so the streams of the called program are still tied to our pipes.Sending messagesEverything is set up now! Let’s send messages!12345678910111213// Parentstring message;cout &lt;&lt; \"Parent: I'll send the child a message.\" &lt;&lt; endl;ofdstream in_stream(CHILD_STDIN_WRITE);in_stream &lt;&lt; \"Hello Child!\\n\";ifdstream out_stream(CHILD_STDOUT_READ);getline(out_stream, message);cout &lt;&lt; \"Parent: Child just said through stdout: \" &lt;&lt; endl &lt;&lt; \"\\t\\\"\" &lt;&lt; message &lt;&lt; \"\\\"\" &lt;&lt; endl;We send the message “Hello Child!” through the write end of the child’s stdin pipe.The child process get it and outputs another message that we read from the read end of the child’s stdout pipe.Pipes I/O with file descriptors using C++ STL streamsYou can see here two simple functions to read and write strings through pipes using file descriptors and C++ STL-like input/output streams.1234567891011121314151617181920212223string read_from_pipe (int file_descriptor)&#123; // We create a C++ stream from a file descriptor // stdio_filebuf is not synced with stdio. // From GCC 3.4.0 on exists in addition stdio_sync_filebuf // You can also create the filebuf from a FILE* with // FILE* f = fdopen(file_descriptor, mode); __gnu_cxx::stdio_filebuf&lt;char&gt; filebuf(file_descriptor, std::ios_base::in); istream stream(&amp;filebuf); // You can also do: // ostringstream stream; // stream &lt;&lt; &amp;filebuf; // return stream.str(); string line; if (stream.good()) &#123; getline(stream, line); &#125; return line;&#125;1234567891011void write_to_pipe (int file_descriptor, const string&amp; line)&#123; __gnu_cxx::stdio_filebuf&lt;char&gt; filebuf(file_descriptor, std::ios_base::out); ostream stream(&amp;filebuf); if (stream.good()) &#123; stream &lt;&lt; line; &#125;&#125;I use the __gnu_cxx::stdio_filebuf class. This class is part of the GNU extensions of the libstdc++ library.From the library documentation:[This class] Provides a layer of compatibility for C/POSIX.This GNU extension provides extensions for working with standard C FILE*’s and POSIX file descriptors. It must be instantiated by the user with the type of character used in the file stream, e.g., stdio_filebuf&lt;char&gt;.With this object we can create a STL istream or ostream giving its contructor the address of our object.I’ve created two C++ classes so we can interact with the child’s streams like they were C++ STL streams instead of using these functions. You can see here the interface.123456789101112131415161718192021class ifdstream : public _fdstream&#123;public: ifdstream(); ifdstream(int file_descriptor); void open(int file_descriptor); ifdstream&amp; operator&gt;&gt; (string&amp; str); size_t getline (char* s, streamsize n); size_t getline (char* s, streamsize n, char delim); ~ifdstream();&#125;;class ofdstream : public _fdstream&#123;public: ofdstream(); ofdstream(int file_descriptor); void open(int file_descriptor); ofdstream&amp; operator&lt;&lt; (const string&amp; str); ~ofdstream();&#125;;With these classes you can create STL-like C++ streams from your file descriptors so you can read and write from/to the pipes with the usual &gt;&gt; and &lt;&lt; operators. I haven’t implemented more functions as this is only a demonstration.That’s all folks! You can now create families of talking processes!Source codeYou can find the full source code on GitHub.The code is in the public domain, you can do whatever you want with it.Improvements and comments are most appreciated.Of course this code is for educational purposes only. If you want to do something serious about file descriptors and C++ streams have a look at boost::iostreams::file_descriptor and boost::iostreams::stream.ResourcesSouce code repositoryYoLinux Tutorial: Fork, Exec and Process controlAdvanced Linux Programming Book: IPC chapterLinux Programmer’s GuideThe GNU C Library manualThe GNU C++ Library manualfileno(3) on C++ Streams: A Hacker’s Lament, Richard B. Kreckel","categories":[{"name":"programming","slug":"programming","permalink":"https://blog.eldruin.com/categories/programming/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"ipc","slug":"ipc","permalink":"https://blog.eldruin.com/tags/ipc/"},{"name":"stl","slug":"stl","permalink":"https://blog.eldruin.com/tags/stl/"}]},{"title":"DSMemorizer","slug":"/dsmemorizer","date":"2009-10-01T07:04:48.000Z","updated":"2018-09-02T10:24:48.000Z","comments":true,"path":"/dsmemorizer/","link":"","permalink":"https://blog.eldruin.com/dsmemorizer/","excerpt":"","text":"DSMemorizer is a homebrew game for the Nintendo DS (also playable in any emulator like DeSmuMe) to help memorizing japanese vocabulary and kanjis (ideograms).DSMemorizer is written in C++ following an object oriented programming. It uses the libraries libnds, EFS_lib for the files, freetype for font rendering and UTF8-CPP to process UTF-8 files. For the databases of symbols and words it uses UTF-8 encoded XML files. The documentation can be generated by Doxygen.It is possible to write your own database in your own language in XML format.Source codeYou can find the souce code of the game here","categories":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/categories/embedded/"}],"tags":[{"name":"embedded","slug":"embedded","permalink":"https://blog.eldruin.com/tags/embedded/"},{"name":"c++","slug":"c","permalink":"https://blog.eldruin.com/tags/c/"},{"name":"game","slug":"game","permalink":"https://blog.eldruin.com/tags/game/"}]}]}